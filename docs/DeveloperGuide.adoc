= Sous Chef - Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
:experimental:
endif::[]
:repoURL: https://github.com/CS2103-AY1819S1-W10-4/main/tree/master

By: `Team W10-4`      Since: `Sep 2018`      Licence: `MIT`

== Setting up

=== Prerequisites

. *JDK `9`* or later
+
[WARNING]
JDK `10` on Windows will fail to run tests in <<UsingGradle#Running-Tests, headless mode>> due to a https://github.com/javafxports/openjdk-jfx/issues/66[JavaFX bug].
Windows developers are highly recommended to use JDK `9`.

. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.


=== Setting up the project in your computer

. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.
. Open link:{repoURL}/src/main/java/seedu/souschef/storage/XmlAdaptedPerson.java[`XmlAdaptedPerson.java`] and
link:{repoURL}/src/main/java/seedu/souschef/ui/MainWindow.java[`MainWindow.java`] and check for any code errors
.. Due to an ongoing https://youtrack.jetbrains.com/issue/IDEA-189060[issue] with some of the newer versions of IntelliJ, code errors may be detected even if the project can be built and run successfully
.. To resolve this, place your cursor over any of the code section highlighted in red. Press kbd:[ALT + ENTER], and select `Add '--add-modules=...' to module compiler options` for each error
. Repeat this for the test folder as well (e.g. check
link:{repoURL}/src/test/java/seedu/souschef/commons/util/XmlUtilTest
.java[`XmlUtilTest.java`] and link:{repoURL}/src/test/java/seedu/souschef/ui/HelpWindowTest.java[`HelpWindowTest.java`]
for
code errors, and if so, resolve it the same way)

=== Verifying the setup

. Run the `seedu.souschef.MainApp` and try a few commands
. <<Testing,Run the tests>> to ensure they all pass.

=== Configurations to do before writing code

==== Configuring the coding style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.adoc[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify,

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS)
. Select `Editor` > `Code Style` > `Java`
. Click on the `Imports` tab to set the order

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

After setting up Travis, you can optionally set up coverage reporting for your team fork (see <<UsingCoveralls#, UsingCoveralls.adoc>>).

[NOTE]
Coverage reporting could be useful for a team repository that hosts the final version but it is not that useful for your personal fork.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based)

==== Getting started with coding

When you are ready to start coding,

1. Get some sense of the overall design by reading <<Design-Architecture>>.
2. Take a look at <<GetStartedProgramming>>.

== Design

[[Design-Architecture]]
=== Architecture

.Architecture Diagram
image::Architecture.png[width="600"]

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder. To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save as picture`.

`Main` has only one class called link:{repoURL}/src/main/java/seedu/souschef/MainApp.java[`MainApp`]. It is responsible
for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

<<Design-Commons,*`Commons`*>> represents a collection of classes used by multiple other components. Two of those classes play important roles at the architecture level.

* `EventsCenter` : This class (written using https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library]) is used by components to communicate with other components using events (i.e. a form of _Event Driven_ design)
* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* <<Design-Ui,*`UI`*>>: The UI of the App.
* <<Design-Logic,*`Logic`*>>: The command executor.
* <<Design-Model,*`ModelSet`*>>: Holds the data of the App in-memory.
* <<Design-Storage,*`Storage`*>>: Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

.Class Diagram of the Logic Component
image::LogicClassDiagram.png[width="800"]

[discrete]
==== Events-Driven nature of the design

The _Sequence Diagram_ below shows how the components interact for the scenario where the user issues the command `delete 1`.

.Component interactions for `delete 1` command (part 1)
image::SDforDeletePerson.png[width="800"]

[NOTE]
Note how the `Model` simply raises a `AppContentChangedEvent` when the Sous Chef data are changed, instead of asking
the `Storage` to save the updates to the hard disk.

The diagram below shows how the `EventsCenter` reacts to that event, which eventually results in the updates being saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

.Component interactions for `delete 1` command (part 2)
image::SDforDeletePersonEventHandling.png[width="800"]

[NOTE]
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be coupled to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between components.

The sections below give more details of each component.

[[Design-Ui]]
=== UI component

.Structure of the UI Component
image::UiClassDiagram.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/souschef/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `GenericListPanel`, `StatusBarFooter`, `BrowserPanel` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that
are in the `src/main/resources/view` folder. For example, the layout of the
link:{repoURL}/src/main/java/seedu/souschef/ui/MainWindow.java[`MainWindow`] is specified in
link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Binds itself to some data in the `Model` so that the UI can auto-update when data in the `Model` change.
* Responds to events raised from various parts of the App and updates the UI accordingly.

// tag::uimodularisation[]
==== Modularisation
*List Panel*

_Brief overview_:
Many of the features (such as MealPlanner, HealPlan, IngredientManager, Recipes, Favourites)
need to use the list panel section to display their own UniqueType classes. Therefore, this
has been abstracted and modularised for easier implementation of usage and for any future
implementation of new components which may need to use the list panel. This is done by inserting
generic classes into the hierarchy.

_Old Hierarchy_:

image::UiPanelOldHierarchy.png[width="800"]

_New Hierachy_:

image::UiPanelNewHierarchy.png[width="800"]

[NOTE]
Not all the components are shown, only MealPlanner and Recipe components are shown
in the diagram as an example. Notice how the new generic abstract classes are simply inserted
between the superclass and subclass of the old hierarchy to give the new hierarchy.

_Explanation_:

With the *GenericListPanel*, *GenericCard* and *GenericPanelSelectionChangedEvent* classes,
new features which wish to use the UI list panel simply have to have their respective
classes extend these three abstract classes and implement their methods accordingly.
Then the respective fxml files for [feature]ListPanel and [feature]Card have to be
created.

_MainWindow.java and ListPanelSwitchEvent.java_:

*ListPanelSwitchEvent* encapsulates an event where the list panel needs to change context.
It extends *BaseEvent* and contains a *Context* attribute to store information on which context
the list panel needs to switch to. +
To switch between different list panels for different features, switchTo[feature]ListPanel()
methods have to be implemented in MainWindow. This method gets the respective filteredList
from the model within modelSet within logic and uses it to change the generalListPanel.
The handleListPanelSwitchEvent() method is invoked when a *ListPanelSwitchEvent* is posted
to the *EventsCenter*, and the method then checks the context attribute of the *ListPanelSwitchEvent*
object to determine which context the list panel needs to switch to, and then calls the correct method.


_Usage_:

Now in order to switch between the different feature list panels, the developer just has to
create their handler method, instantiating a *ListPanelSwitchEvent* with their desired context
and then raising the event by posting it to the *EventsCenter*.

// end::uimodularisation[]

// tag::logicComponent[]

[[Design-Logic]]
=== Logic component

[[fig-LogicClassDiagram]]
.Structure of the Logic Component
image::LogicClassDiagram.png[width="800"]

*API* :
link:{repoURL}/src/main/java/seedu/souschef/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `AppContentParser` class to parse the user command.'
.  `AppContentParser` passed necessary model to each feature parser such as `IngredientParser` according to the context.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a recipe) and/or raise events.
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("add onion 100
gram 10-23-2018")` API call.

.Interactions Inside the Logic Component for the adding ingredient
image::LogicSequenceDiagram.png[width="800"]

// end::logicComponent[]

// tag::modelComponent[]

[[Design-Model]]
=== Model component

.Structure of the Model Component
image::ModelComponent.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/souschef/model/ModelSet.java[`ModelSet.java`],
link:{repoURL}/src/main/java/seedu/souschef/model/Model.java[`Model.java`]

The `ModelSet`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Sous Chef application data.
** Contains multiple `Model` each in-charge of a feature's data.
* shares a single instance of VersionedAppContent to ensure single version of truth.
* does not depend on any of the other three components.

The `Model`,

* each represents a feature-unique data.
** ensures data abstraction for each feature.
* is reusable as model is now generic.
* exposes an unmodifiable `ObservableList<T extends UniqueType>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.

// end::modelComponent[]


// tag::storage[]
[[Design-Storage]]
=== Storage component

.Structure of the Storage Component (The given diagram only shows the extensions of 2 functions.)
image::StorageClassDiagramRevamp.png[width="800"]

*API* : link:{repoURL}/src/main/java/seedu/souschef/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the various xml files from each of the different functions. Namely recipe.xml, ingredients.xml and healthplan.xml
* can do a context switch for storing information into the correct xml file for the function.
* generalized in its implementation for easy extension
* controls information by passing a single appContent unit around the system.
* With the new implementation of the storage component, calls at the upper layers are generalized and all components shares
common calls for load and saving.
* The new storage component introduces a new abstract parent (XmlFeatureStorage) and also a new interface
(XmlSerializableGeneric) to make all the calls of load and save to be generic to allow easy functional implementation
without much creation of new methods at the storage level. Just by calling the context switch and also the save and load
calls the intended result will be achieved.

// end::storage[]


[[Design-Commons]]
=== Common classes

Classes used by multiple components are in the `seedu.souschef.commons` package.

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::ingredientManager[]
=== Ingredient Manager
==== Total management of ingredients that user currently have
Ingredient Manager is an address book of ingredients. With the basic functions of a normal address book such as
add, edit, delete and list, Ingredient Manager has some useful functions specific for management of ingredients. +
First of all, converting to a common unit. Ingredients has different serving units, but most of them can be converted to
common unit to be compared with each other and to make arithmetic calculation easier. It uses gram for mass and
centimeter cube for volume as a common unit. Serving unit dictionary implemented with static arraylist is referred
when the
conversion is done. +
Secondly, when you apply the list command, ingredients are sorted by date. Since ingredients have to be consumed in a
 certain period, it keeps user be reminded of old ingredients.

==== View recipes according to ingredients, and check shop amount
This command works on separate context called cross, because the result of command manipulates recipes, not
ingredients. This commands
filters(include) and sorts(prioritize) recipes based on ingredients given in the command. However, this command is
closely tied to the information stored in Ingredient Manager. First of all, you can provide all ingredients in
Ingredient
 Manager as parameter for filtering or sorting. This might be useful when a user wants to find food that can be
 cooked while maximizing the use of existing ingredients. Secondly, for the recipes that are on the list as a result
 of the commands, additionally needed amount of each ingredient in a recipe is calculated. Because ingredients in
 Ingredient Manager are considered as the ones that the user currently have, their amounts are subtracted from the
 desired amount calculated considering the number of servings. If the user has selected a certain recipe and cooked,
 she can go back to Ingredient Manager and edit amount of ingredients or delete ingredients used for cooking.
// end::ingredientManager[]

// tag::mealplannerimplementation[]
=== Meal Planner feature
==== Current Implementation

===== Model
The Meal Planner feature is supported by the classes *Meal* and *Day*.


****
Supporting classes:

* *Day*: encapsulates a *LocalDate* _date_  and an *ObservableList<Meal>* _mealList_
containing 3 meals (breakfast, lunch, dinner). *Day* objects are always instantiated
with 3 empty *Meal* objects in the _mealList_.
** An empty *Day* is defined as having 3 empty meals in its _mealList_.
** 2 *Day* objects are defined as same (through overriding equals() method) as long
as they have the same *LocalDate* _date_. This is to ensure no duplication of dates
within the Meal Planner.

* *Meal*: abstract class which encapsulates a *Optional<Recipe>* _recipe_, an *int* _index_
indicating which meal index each *Meal* object is (0 for breakfast, 1 for lunch, 2 for dinner),
and a *String* _slot_ containing its corresponding name.

* *Breakfast*: inherits from *Meal* class and represents the breakfast meal slot of the day.
Contains a predefined integer index of 0 and a predefined String slot name of "breakfast".

* *Lunch*: inherits from *Meal* class and represents the lunch meal slot of the day.
Contains a predefined integer index of 1 and a predefined String slot name of "lunch".

* *Dinner*: inherits from *Meal* class and represents the dinner meal slot of the day.
Contains a predefined integer index of 2 and a predefined String slot name of "dinner".

** An empty *Meal* is defined as having no recipe, i.e. empty *Optional*.
****

Class diagram:

image::MealPlannerClassDiagram.png[width="800"]

Brief explanation:

Meal Planner is currently implemented as a list of non-empty *Day* objects. This is
ensured as *Day* objects are only instantiated when recipes are added to a certain
_date_, with that _date_ being assigned to its *Day* object. When all the recipes
are deleted from a certain *Day*, the *Day* object is removed from the Meal Planner.
*Day* objects in the Meal Planner list panel are sorted in chronological order according
to their dates. This is done by sorting the list when instantiated and when *Day* objects
are added or removed.

===== Logic
For Meal Planner commands to be accessible, context has to be switched to "Meal Planner
via the command `-mealplanner` (except for the case of the `plan` command for adding recipes
to the Meal Planner, which has to be done in the recipe context since the user needs to be able
to see the recipes). From there, the Meal Planner commands can be used and
*AppContentParser* will redirect the different commands to their respective CommandParser.

====== _Plan Command_: `plan`
The plan command adds a recipe from the _recipeModel_ to the _mealPlannerModel_. Therefore
both models have to be passed to *PlanMealCommandParser*.

Within *PlanMealCommandParser*, it parses the target _date_ from a *String* into a *LocalDate*.
Only dates from the present or future are allowed to be entered.
This *LocalDate* object is then used to find out whether _mealPlannerModel_ currently
contains a *Day* with the target _date_. If such a *Day* object already exists, it is
taken from _mealPlannerModel_ to be used in *PlanMealCommand*. Else, a new *Day* object is
instantiated with the target *LocalDate* _date_. The target _meal_ is then taken from
the *Day* object. _mealPlannerModel_, target _day_ target _recipe_ and target _meal_ are then passed
to *PlanMealCommand*.

Within the execute method of *PlanMealCommand*, target _recipe_ is then added the target _meal_ and
target _day_ is then added to mealPlannerModel.

Finally, the new content is committed via _mealPlannerModel.commitAppContent()_.

====== _Select Command_: `select`
The select command selects a recipe of a specified meal of a specified day and displays the details
of the recipe (ingredients, instructions, etc) in the DetailPanel. +
*MealPlannerParser* invokes the parseMealRecipe() command of *SelectCommandParser*. The desired
index and meal index are parsed from the user input and used to extract the _recipe_ from the
specified day's desired meal index. Using this _recipe_, the _recipeModel_ is searched and the
index of the matching recipe is returned. +
The index and the _recipeModel_ are then passed to
a *SelectCommand* which executes the displaying of the recipe details in the same manner as
in the recipe context.

====== _Clear Command_: `clear`
The clear command simply clears the Meal Planner of all days. +
This is done by setting (i.e. replacing) the existing UniqueList of _mealPlannerModel_
with a new empty UniqueList.

====== _Delete Command_: `delete`
The delete command deletes a specified *Day* from the _mealPlannerModel_ along with all its _meals_.
The *Day* is specified by its index as seen on the list panel. +
*MealPlannerParser* invokes the parseMealPlan() method of *DeleteCommandParser*. The user input
is then parsed to get the index of the *Day* to be deleted. The *Day* object at the given index
of the _mealPlannerModel_ list is then deleted.

// end::mealplannerimplementation[]

// tag::favouritesimplementation[]
=== Favourites list

This feature allows users to have a quick reference to all of their favourite recipes. Users are able to add recipes
that they like a lot, or that they cook often to the favourites list. Users are also able to search, display details,
and remove any entry within the favourites list.

==== Adding to Favourites
While browsing the recipes in the recipe context, and when a user likes a recipe at a particular `INDEX`, they can
execute the `favourite INDEX` command. The recipe selected would be copied from the recipe model, and added to an array
list in the favourites model.
// end::favouritesimplementation[]

// tag::recipeManagement[]
=== Recipe Management
==== Multi-line Recipe Adding
===== Current Implementation
As the adding of recipes deal with lengthy input parameters from the basic details such as name to a list of
instructions, single-line add command proves to be inefficient and often providing an inconvenient user experience.
To allow flexibility, adding of recipes have been implemented as a multi-line command fitting into this CLI application.

Multi-line add function consists of 3 main commands: `add` `cont` `end`. The `add` command requires user input of the
recipe basic information such as `Name`, `Difficulty`, `CookTime` and the optional `Tag`. The `cont` command requires
 user input of the recipe `Instruction`. Each `cont` command allows only 1 `Instruction`. Again this is to
 break down the lengthy input parameter of `Instruction`.  Lastly, with the `end` command the `Recipe` is being
 recognised and is added to the `Model`. +

The following is the sequence diagram of the `add` command:

image::recipe_add_add.png[width="1000"]
Once user's input is being parsed, a `RecipeBuilder` is created instead of a `Recipe` instance. This `RecipeBuilder`
will be stored in `History` when the command is being executed.
[NOTE]
====
Repeating use of `add` will replace existing `RecipeBuilder` rendering the previous data unsaved.
====

The following is the sequence diagram of the `cont` command:

image::recipe_add_cont.png[width="1000"]
Upon parsing the user's input that contains `Instruction`, a `Instruction` instance will be created. This
`Instruction` is to be passed to the command for execution. The execution process once again make use of the `History`
to append the `Instruction` into `RecipeBuilder`.

The following is the sequence diagram of the `end` command:

image::recipe_add_end.png[width="1000"]
Upon receiving the `end` command, `Recipe` will be built from the `RecipeBuilder`. The parsing process checks to
ensure that the `Recipe` built contains at least a single `Instruction` to prevent adding of `Recipe` without
`Instruction`. With a valid `Recipe`, a `AddCommand` will be created and the `RecipeBuilder` in `History` will be
cleared (i.e. set to null). This `AddCommand` when executed will add the `Recipe` into `Model`.

===== Why it is implemented that way:
Due to the nature of a multi-line add command where the `Recipe` is incomplete together with the inability to execute
 the add
 function immediately, 2 mechanisms namely, a builder and a historical storage, have to be put
  in place. The builder works effectively in managing the data of a partial `Recipe` while allowing continuous
  modification. The historical storage, `History` in this context, ensures that lossless partial
  `Recipe` data. Moreover, since `History` interaction with commands has already been well establish in Logic
  component and a partial `Recipe` is indeed a representation the historical commands, storing in `History`
  becomes a dominant choice.

===== Alternatives:
Adding of incomplete recipe to the model and edit that recipe with the subsequent commands.
Pros - Make use of existing add and edit command without the need of additional implementation.
Cons - Model contains incomplete recipe that violates the validity of recipe data. This might be exploited and in the
 process the application can be filled with incomplete recipes.

==== All-field Recipe Search
The all-field recipe search matches keywords with details of `Recipe`.
Each keyword goes through the matching process against the `Name`, `Tag`, `Difficulty`, `CookTime` and even
`Ingredient` from each `Instruction` of every recipe.
Such search feature provides a complex querying, rather than a superficial search on merely recipes' name.

===== Current Implementation
To implement this feature, recipe `Model` is implemented with `FilteredList`. This list takes in a predicate to
filter away recipes that does not meet the requirement.

The desired search keywords, once parsed as `List` of `String` will be turned to `Stream`. Each keyword is checked
against a recipe `Name` for any matching word, `Difficult` for exact matching value, `Tag` for any matching
word, and `Ingredient` for any matching `IngredientDefinition`. All keywords must return true (i.e. matching at least
 one attribute of the recipe) before the recipe is deemed fit to be kept in the `FilteredList`.

The following code snippet shows how the predict determines each recipe: +

include::../src/main/java/seedu/souschef/model/recipe/NameContainsKeywordsPredicate.java[lines=20..34]

The following sequence diagram shows how the keywords are being parsed to feed into the predicate:

image::recipe_search_seq.png[width="1000"]

===== Why it is implemented that way:
Due to the existing data structure implemented by model, to access the attributes within a recipe, the system needs
to use its getter and perform matching with its keywords. Hence, a filter via predicate testing is deemed fit.

===== Alternatives:
Tag saving recipes that uses it. +
Pros - Search done more effectively as the system only need to display all recipes stored in a tag +
Cons - Bi-directional association, increase difficulty in maintaining data integrity
// end::recipeManagement[]


// tag::healthplan[]
=== Health Plan

This is a feature that users can access to have health plans to manage their diet and health due to dietary
needs of their choice. Users are able to add a health list to based on their specifications:
whether they intend to gain/lose/maintain weight from their
set age, current weight and also their current height. this will then tell them what is the required calories to
eat per day to hit their target.

==== Current implementation

* Users are able to add to the list based on their personal settings: name, age, height, weight, target weight,
 duration, scheme (gain/loss/maintain)
* Users are able to delete entries that they do not want to keep anymore.
* Users are aso able to edit entries which information is incorrect.
* Users are able to add days of the meal planner segment into chosen health plan
* Users are able to display all days of the meal planner segment concurrently with the health plan lists
* Users are able to display the details of a health plan to see the days stored and also other information
* Users are able to remove days of the health plan they added.
* Users are now able to view the calories count from the meals they included into the healthplan and when the details of
the health plan is shown the target to hit will be shown to the user, in value and also bar chart. Along with such info,
there is also a percentage met to show how much of the target is already achieved.

==== Ongoing implementation (Implementing plan comparisons)

This new implementation of this feature will allow the users to select 2 plans of their choice and compare
with a side by side comparison of the calories consumed. This information will be displayed to the user much like the show
details command that is available with slight tweaks. There will not be a percentage met but instead the feature will
try to cover breakdown of the calories intake by day using the set duration of the targetted plans.
This will provided clarity of the day by day consumption of calories of the user across 2 plans.
The information will be in calculated values and then displayed in a series of bar graphs for quick understanding of the
information by just looking at the graphs.


==== Ongoing implementation (Expiry of health plans)

The new implementation of this feature should have an expiry feature that counts down the system base on the app's date
 against the duration set by the user.

// end::healthplan[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See <<Implementation-Configuration>>)
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

[[Implementation-Configuration]]
=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: `config.json`).

== Documentation

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

.Saving documentation as PDF files in Chrome
image::chrome_save_as_pdf.png[width="300"]

[[Docs-SiteWideDocSettings]]
=== Site-wide Documentation Settings

The link:{repoURL}/build.gradle[`build.gradle`] file specifies some project-specific https://asciidoctor.org/docs/user-manual/#attributes[asciidoc attributes] which affects how all documentation files within this project are rendered.

[TIP]
Attributes left unset in the `build.gradle` file will use their *default value*, if any.

[cols="1,2a,1", options="header"]
.List of site-wide attributes
|===
|Attribute name |Description |Default value

|`site-name`
|The name of the website.
If set, the name will be displayed near the top of the page.
|_not set_

|`site-githuburl`
|URL to the site's repository on https://github.com[GitHub].
Setting this will add a "View on GitHub" link in the navigation bar.
|_not set_

|`site-seedu`
|Define this attribute if the project is an official SE-EDU project.
This will render the SE-EDU navigation bar at the top of the page, and add some SE-EDU-specific navigation items.
|_not set_

|===

[[Docs-PerFileDocSettings]]
=== Per-file Documentation Settings

Each `.adoc` file may also specify some file-specific https://asciidoctor.org/docs/user-manual/#attributes[asciidoc attributes] which affects how the file is rendered.

Asciidoctor's https://asciidoctor.org/docs/user-manual/#builtin-attributes[built-in attributes] may be specified and used as well.

[TIP]
Attributes left unset in `.adoc` files will use their *default value*, if any.

[cols="1,2a,1", options="header"]
.List of per-file attributes, excluding Asciidoctor's built-in attributes
|===
|Attribute name |Description |Default value

|`site-section`
|Site section that the document belongs to.
This will cause the associated item in the navigation bar to be highlighted.
One of: `UserGuide`, `DeveloperGuide`, ``LearningOutcomes``{asterisk}, `AboutUs`, `ContactUs`

_{asterisk} Official SE-EDU projects only_
|_not set_

|`no-site-header`
|Set this attribute to remove the site navigation bar.
|_not set_

|===

=== Site Template

The files in link:{repoURL}/docs/stylesheets[`docs/stylesheets`] are the https://developer.mozilla.org/en-US/docs/Web/CSS[CSS stylesheets] of the site.
You can modify them to change some properties of the site's design.

The files in link:{repoURL}/docs/templates[`docs/templates`] controls the rendering of `.adoc` files into HTML5.
These template files are written in a mixture of https://www.ruby-lang.org[Ruby] and http://slim-lang.com[Slim].

[WARNING]
====
Modifying the template files in link:{repoURL}/docs/templates[`docs/templates`] requires some knowledge and experience with Ruby and Asciidoctor's API.
You should only modify them if you need greater control over the site's layout than what stylesheets can provide.
The SE-EDU team does not provide support for modified template files.
====

[[Testing]]
== Testing

=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`)

=== Types of tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include,
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.souschef.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include,
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.souschef.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.souschef.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.souschef.logic.LogicManagerTest`


=== Troubleshooting Testing
**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `HelpWindow.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

== Dev Ops

=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Coverage Reporting

We use https://coveralls.io/[Coveralls] to track the code coverage of our projects. See <<UsingCoveralls#, UsingCoveralls.adoc>> for more details.

=== Documentation Previews
When a pull request has changes to asciidoc files, you can use https://www.netlify.com/[Netlify] to see a preview of how the HTML version of those asciidoc files will look like when the pull request is merged. See <<UsingNetlify#, UsingNetlify.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/seedu/souschef/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, Sous Chef depends on the http://wiki.fasterxml
.com/JacksonHome[Jackson library] for XML parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives. +

[appendix]
== Product Scope

*Target user profile*:

* prefer home-cooked meals and has a need to manage meal preparation schedule
* interested to explore different recipes and receive suggestions on the next meal
* requires a kitchen-helper providing step-by-step instructions
* like to keep track of nutrition and calories intake
* has needs for a shopping list based on the meals planned

*Value proposition*: innovate, plan and guide health-conscious occupied working adults in preparing home-cooked meals

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
=== Ingredient Management
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...

|`* * *` |user |limit the search result of recipes to what I have in my inventory |cook a meal without buying additional ingredients

|`* * *` |user |Be informed of the name/amount of ingredients that I am lacking |so that I can buy the shortfall

|`* * *` |user with ingredient near expiry |I can refer to the purchase date on ingredient manager and search for recipes that include those ingredients |use up my ingredients near expiry

|`* * *` |user |see recipes that can use the most number of ingredients in the ingredient manager |cook with the maximum utilization of my ingredients

|`* *` |user who wants to cook more than one serving of dishes |get the accordingly calculated missing amount of ingredients |-
|=======================================================================
// tag::mealplanner[]
=== Meal Planner
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...

|`* * *` |user |plan my meals for breakfast, lunch and dinner |I can remember my meals for each day

|`* * *` |fickle-minded user |edit my meal plans |I can add different recipes if I change my mind

|`* * *` |efficient user |clear the meal planner immediately at the end of the week |I can save time

|`* *` |health-conscious user |view the nutritional value of each recipe |I can choose recipes according to my nutritional needs

|`*` |meticulous user |view the time taken for each recipe |I can plan ahead for meal preparations to fit my schedule
|=======================================================================
// end::mealplanner[]
=== User Profiling
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...

|`* * *`|undecided user |get random recipe suggestions |get new ideas on what to cook

|`* * *` |user |get suggestions to cook based on my viewing and cooking history |learn to cook similar dishes that I may like

|`* * *` |user |favourite a recipe that I really like | save them into my favourites for easy reference

|`* * *` |user |remove a recipe from my favourites |remove a recipe that I no longer like

|`* * *` |user |list out all my favourite recipes|view all of my favourite recipes at a glance
|=======================================================================
=== Recipes Management and cook-mode
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...

|`* * *` |indian |search for recipes of Indian dishes	|prepare a wholesome meal for my family

|`* * *` |vegetarian |search for vegan option |prepare self-make food for my dietary requirements

|`* * *` |mum |search for kids-friendly recipes |prepare food that is to my kids liking

|`* *` |amateur cook |follow through the step-by-step cooking instructions explicitly |my cooking process is guided

|`*` |user |provide suggestions to a recipe |improve on the recipe to value-add the community

|`*` |picky user |search for recipes with good reviews |prepare tasty food that is worth the calories

|`*` |user |“like/dislike” reviews on a recipe made by other users	 |credit/discredit valid/invalid reviews
|=======================================================================


=== Health Plan
|========================================================================
|Priority | As a... |I want to ... | So that I can...

|`* * *`|new user| be able to easily use the interface without hassle | easily learn the interface without difficulty

|`* *`|health-conscious user| be able to view the nutritional breakdown| Know what food to cut down or replace

|`* *`|fickle user | be able to change plans or make new plans on the go | make changes when errors are made

|`* *`|user trying to be more healthy | be recommended healthy recipes by the system | save the effort needed to
search online

|`*`|experimental user| be able to have many plans | try out different plans on the go
|========================================================================



[appendix]
== Use Cases

(For all use cases below, the *System* is the `Sous Chef` and the *Actor* is the `user`, unless specified otherwise)

=== Ingredient Management
[discrete]
=== Use case: UC11 – List Ingredient

*MSS*

1. User requests to list ingredients.
2. System shows list of ingredients.
+
Use case ends.

[discrete]
=== Use case: UC12 – Add Ingredient

*MSS*

1. User requests to add an ingredient.
2. System adds the ingredient at the rear of the list and shows the list.
+
Use case ends.

*Extensions*

[none]
* 1a. System prompt insufficient/invalid contents.
+
[none]
** 1a1. System show the message.
+
Use case ends.

[discrete]
=== Use case: UC13 – Edit Ingredient

*MSS*

1. User requests to edit an ingredient.
2. System reflects the change to the list and show the list.
+
Use case ends.

*Extensions*

[none]
* 1a. System prompt insufficient/invalid contents.
+
[none]
** 1a1. System show the message.
+
Use case ends.

[discrete]
=== Use case: UC14 – Delete Ingredient

*MSS*

1. User requests to delete an ingredient.
2. System deletes the ingredient and shows the list.
+
Use case ends.

*Extensions*

[none]
* 1a. The ingredient does not exist in the ingredient manager.
+
[none]
** 1a1. System show the message.
+
Use case ends.

[discrete]
=== Use case: UC15 – Find Ingredient

*MSS*

1. User requests to find ingredients.
2. System show the list of ingredients that contains the keywords.
+
Use case ends.

[discrete]
=== Use case: UC16 – Search recipes according to ingredients

*MSS*

1. User selects both mandatory and desirable ingredients for the search.
2. System shows the filtered and sorted list of recipes.
3. User selects a recipe.
4. System shows recipe specifying missing ingredients and its amount, calculated according to the number of servings.
+
Use case ends.

=== Meal Planner
[discrete]
=== Use case: UC21 – Add recipe to meal planner

*MSS*

1. User requests to list available recipes.
2. System shows list of available recipes.
3. User selects desired recipe and adds it to the desired meal index.
4. System shows the recipe listed under the indicated meal index.
+
Use case ends.

[discrete]
=== Use case: UC22 – Delete recipe from meal planner

*MSS*

1. User requests to view current meal plan.
2. System shows current meal plan.
3. User requests to delete unwanted recipe.
4. System shows specified meal index as empty.
+
Use case ends.

[discrete]
=== Use case: UC23 – View meal plan

*MSS*

1. User requests to view current meal plan.
2. System shows current full meal plan.
+
Use case ends.

[discrete]
=== Use case: UC24 – View meal recipe

*MSS*

1. User requests to view recipe for a specific meal index.
2. System shows the full recipe of the specified meal index.
+
Use case ends.

=== User Profiling
[discrete]
=== Use case: UC31 - Request surprise recipe

*MSS*

1. User requests to wants to cook something new, but has no idea what they want to try.
2. User request for surprise recipe
3. System displays random recipe
+
Use case ends.

[discrete]
=== Use case: UC32 – Favourite recipe

*MSS*

1. User lists a selection of recipes (Based on his search parameters).
2. User selects a recipe to view.
3. User likes that recipe, and adds it to their "Favourite Recipe" list.
+
Use case ends.

[discrete]
=== Use case: UC33 – Suggest recipe

*MSS*

1. User wants to try a new recipe.
2. A list of 3 new recipes (That the user hasn't cooked before, and based on their preferences, viewing and cooking history) will be displayed to the user.
+
Use case ends.

=== Recipes Management and cook-mode
[discrete]
==== Use case: UC41 – Search for Recipe
*MSS*

1.	User chooses to search for recipe.
2.	System requests for details.
3.	User enters keywords.
4.	System displays recipes.
5.	User enters keywords.
+
Steps 3 – 5 are repeated until search result becomes too narrow or user choose to look at existing result.
+
Use case ends.

[discrete]
==== Use case: UC42 – View Recipe
*MSS*

1.	User +++<u>searches for recipe (UC41)</u>+++.
2.	User chooses a recipe.
3.	System displays recipe details.
+
Use case ends.

[discrete]
==== Use case: UC44 – Navigate Recipe
*MSS*

1.	User +++<u>views recipe (UC42)</u>+++.
2.	User chooses to enter navigation mode.
3.	System displays instruction.
4.	User chooses next instruction.
+
Steps 3 – 4 are repeated until end of recipe’s instruction or user chooses to end navigation.
+
Use case ends.


*Extensions*
[none]
* 3a. 	System displays timer for duration specific instruction.
* 3b. 	User chooses to start timer.
* 3c. 	System displays countdown.
* 3d. 	System displays alert when timer ends.
+
Use case resumes at step 3.

* *c. 	At any time, user chooses to end timer.
[none]
** c1. 	System ends timer.
+
Use case resumes at step 3.

[discrete]
==== Use case: UC45 – Add Recipe
*MSS*

1.	User chooses to add recipe.
2.	System requests for details.
3.	User enters details.
4.	User chooses to save.
5.	System displays saved recipe.
+
Use case ends.

*Extensions*
[none]
* 4a. 	System detects missing field(s).
* 4a1. 	System requests for input of missing field(s).
* 4a2. 	User enters details.
* Steps 4a1 – 4a2 are repeated until the data entered are correct.
* Use case resumes at step 5.

=== Health planner
[discrete]
==== Use case: UC51 – Create plan

*MSS*

1. User requests to create a plan.
2. User enters details for the plan.
3. System creates the plan.
+
Use case ends.

*Extensions*

[none]
* 2a. User enters invalid details.
+
[none]
** 2a1. System shows error message.
+
Use case resumes at 2.

[discrete]
==== Use case: UC52 – Edit plan

*MSS*

1. User requests to edit a plan.
2. System retrieves the list of plans by user.
3. User select the plan to edit.
4. User enters the new details to the plan.
5. System updates the details.
+
Use case ends.

*Extensions*

[none]
* 2a. No prior plan.
+
Use case ends.

[none]
* 4a. Invalid details.
+
[none]
** 4a1. System shows an error message.
+
Use case returns to 4.

[discrete]
==== Use case: UC53 – Delete plan

*MSS*

1. User requests to delete plan.
2. System shows list of plans.
3. User selects plan to delete.
4. System deletes the selected plan.
+
Use case ends.

*Extensions*

[none]
* 2a. No pre-existing plan.
+
Use case ends.

[discrete]
==== Use case: UC54 – Enter dietary intakes for the day

*MSS*

1. User request to enter intake.
2. System shows list of plans.
3. User selects plan from list.
4. System shows list of recipes to select.
5. User selects recipe to add into list.
6. System adds the recipe to list.
+
Use case ends.

*Extensions*

[none]
* 2a. No existent plan.
+
Use case ends.

[none]
* 4a. No recipe to show.
+
Use case ends.

[discrete]
==== Use case: UC55 – Remove an recipe from the dietary intakes for the day

*MSS*

1. User request to remove recipe from intake list.
2. System shows list of recipes.
3. User selects recipe from the list.
4. System removes the selected recipe from the list.
+
Use case ends.

*Extensions*

[none]
* 2a. No prior ingredient.
+
Use case ends.

[discrete]
==== Use case: UC56 – View nutritional Intake

*MSS*

1. User requests to view nutritional intake entered.
2. System retrieves the list of intakes to show the user.
3. System retrieves the nutritional facts based on the recipes in the list to show the user.

*Extensions*

[none]
* 2a. No data entered previously.
+
Use case ends.

[discrete]
==== Use case: UC57 – Compare actual intake against target

*MSS*

1. User requests to compare the entered data against set target.
2. System shows Target set by User.
3. System calculates and shows the actual intake by user.
4. System calculates the difference in the 2 scores and shows the user the percentage difference(positive or negative)
from set target.
+
Use case ends.

[appendix]
== Non Functional Requirements

.  Should work on any <<mainstream-os,mainstream OS>> as long as it has Java `9` or higher installed.
.  Should be able to hold up to 1000 recipes without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.

[appendix]
== Glossary

[[mainstream-os]] Mainstream OS::
Windows, Linux, Unix, OS-X

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample recipes. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

=== Adding of recipe
. Adding of a non-duplicate recipe
.. Prerequisites: Switched to `-recipe` context and recipe to be added is not in SousChef.
.. Test case: `add n/Chicken Rice d/3 c/20M` `cont i/Remove skin from #chicken 500 gram.` `cont i/Boil chicken in
#water 700 ml for 20m c/20M` `end` +
Expected: Recipe added to the end of recipes list. Details of the added recipe shown in the status message. Timestamp
 in the status bar is updated.
 .. Test case: `add n/Tuna Roll d/3 c/10M` `end` +
 Expected: No recipe is added. Error details shown in the status message. Status bar remains the same.
 . Adding of a duplicate recipe
 .. Prerequisites: Switched to `-recipe` context.
 .. Test case: `add n/Egg Roll d/2 c/10M` `cont i/Spread #rice 100 gram on the mat.` `cont i/Put #egg 1 piece on top
 of the rice.` `cont i/Roll the rice.` `end` `add n/Egg Roll d/2 c/10M` +
 Expected: No recipe is added. Error details shown in the status message. Status bar remains the same.

=== Editing a recipe
. Editing a recipe while all recipes are listed

.. Prerequisites: Switched to `-recipe` context and list all recipes using the `list` command. Multiple recipes in the
list.
... Test case: `edit 1 n/Chicken Burger` +
Expected: First recipe is updated with a new name. Details of the edited recipe shown in the status message. Timestamp in the status bar is updated.
... Test case: `edit 1` +
Expected: No recipe is edited. Error details shown in the status message. Status bar remains the same.

=== Deleting a recipe

. Deleting a recipe while all recipes are listed

.. Prerequisites: Switched to `-recipe` context and list all recipes using the `list` command. Multiple recipes in the
list.
.. Test case: `delete 1` +
   Expected: First recipe is deleted from the list. Details of the deleted recipe shown in the status message.
   Timestamp
   in the status bar is updated.
.. Test case: `delete 0` +
   Expected: No recipe is deleted. Error details shown in the status message. Status bar remains the same.
.. Other incorrect delete commands to try: `delete`, `delete x` (where x is larger than the list size) +
   Expected: Similar to previous.

=== Finding a recipe
. Finding a recipe while all recipes are listed

.. Prerequisites: Switched to `-recipe` context and list all recipes using the `list` command. Multiple recipes in the
lsit.
.. Test case: `find vegetarian noodles 1 20M` +
Expected: Recipes meeting all the keywords is listed. Number of listed recipes shown in the status message. Status bar remains the same.
.. Test case: `find` +
Expected: No recipe listed. Error details shown in the status message. Status bar remains the same.
