= Developer Guide
:site-section: DeveloperGuide
:toc:
:toc-title:
:sectnums:
:imagesDir: images
:repoURL: https://github.com/CS2103-AY1819S1-F11-3/main
:stylesDir: stylesheets
:xrefstyle: full
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
:warning-caption: :warning:
:experimental:
endif::[]
:repoURL: https://github.com/se-edu/addressbook-level4/tree/master

== Disclaimer
This guide was adapted from relevant parts of the developer guide from AB4 (https://github.com/nus-cs2103-AY1819S1/addressbook-level4). This project and AB4 are distributed under the MIT license.

== Setting up

=== Prerequisites
JDK 9 or later

JDK 10 on Windows will fail to run tests in headless mode due to a JavaFX bug. Windows developers are highly recommended to use JDK 9.
IntelliJ IDE

[Note]
IntelliJ by default has Gradle and JavaFx plugins installed.
Do not disable them. If you have disabled them, go to File > Settings > Plugins to re-enable them.

=== Setting up the project in your computer
Fork this repo, and clone the fork to your computer

Open IntelliJ (if you are not in the welcome screen, click File > Close Project to close the existing project dialog first)

Set up the correct JDK version for Gradle

Click Configure > Project Defaults > Project Structure

Click New… and find the directory of the JDK

Click Import Project

Locate the build.gradle file and select it. Click OK

Click Open as Project

Click OK to accept the default settings

Open a console and run the command gradlew processResources (Mac/Linux: ./gradlew processResources). It should finish with the BUILD SUCCESSFUL message.
This will generate all resources required by the application and tests.

Open XmlAdaptedtask.java and MainWindow.java and check for any code errors

Due to an ongoing issue with some of the newer versions of IntelliJ, code errors may be detected even if the project can be built and run successfully

To resolve this, place your cursor over any of the code section highlighted in red. Press ALT+ENTER, and select Add '--add-modules=…' to module compiler options for each error

Repeat this for the test folder as well (e.g. check XmlUtilTest.java and HelpWindowTest.java for code errors, and if so, resolve it the same way)

=== Verifying the setup
Run the seedu.address.MainApp and try a few commands

Run the tests to ensure they all pass.

=== Configurations to do before writing code
==== Configuring the coding style
This project follows oss-generic coding standards. IntelliJ’s default style is mostly compliant with ours but it uses a different import order from ours. To rectify,

Go to File > Settings… (Windows/Linux), or IntelliJ IDEA > Preferences… (macOS)

Select Editor > Code Style > Java

Click on the Imports tab to set the order

For Class count to use import with '*' and Names count to use static import with '*': Set to 999 to prevent IntelliJ from contracting the import statements

For Import Layout: The order is import static all other imports, import java.*, import javax.*, import org.*, import com.*, import all other imports. Add a <blank line> between each import

Optionally, you can follow the UsingCheckstyle.adoc document to configure Intellij to check style-compliance as you write code.

==== Updating documentation to match your fork
After forking the repo, the documentation will still have the SE-EDU branding and refer to the se-edu/addressbook-level4 repo.

If you plan to develop this fork as a separate product (i.e. instead of contributing to se-edu/addressbook-level4), you should do the following:

Configure the site-wide documentation settings in build.gradle, such as the site-name, to suit your own project.

Replace the URL in the attribute repoURL in DeveloperGuide.adoc and UserGuide.adoc with the URL of your fork.

==== Setting up CI
Set up Travis to perform Continuous Integration (CI) for your fork. See UsingTravis.adoc to learn how to set it up.

After setting up Travis, you can optionally set up coverage reporting for your team fork (see UsingCoveralls.adoc).

Coverage reporting could be useful for a team repository that hosts the final version but it is not that useful for your personal fork.
Optionally, you can set up AppVeyor as a second CI (see UsingAppVeyor.adoc).

Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based)

==== Getting started with coding
When you are ready to start coding,

Get some sense of the overall design by reading Section 2.1, “Architecture”.

Take a look at Appendix A, Suggested Programming Tasks to Get Started.

== Design
=== Undo/Redo feature
==== Current Implementation

The undo/redo mechanism is facilitated by `VersionedAddressBook`.
It extends `AddressBook` with an undo/redo history, stored internally as an `addressBookStateList` and `currentStatePointer`.
Additionally, it implements the following operations:

* `VersionedAddressBook#commit()` -- Saves the current address book state in its history.
* `VersionedAddressBook#undo()` -- Restores the previous address book state from its history.
* `VersionedAddressBook#redo()` -- Restores a previously undone address book state from its history.

These operations are exposed in the `Model` interface as `Model#commitAddressBook()`, `Model#undoAddressBook()` and `Model#redoAddressBook()` respectively.

Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.

Step 1. The user launches the application for the first time. The `VersionedAddressBook` will be initialized with the initial address book state, and the `currentStatePointer` pointing to that single address book state.

image::UndoRedoStartingStateListDiagram.png[width="800"]

Step 2. The user executes `delete 5` command to delete the 5th person in the address book. The `delete` command calls `Model#commitAddressBook()`, causing the modified state of the address book after the `delete 5` command executes to be saved in the `addressBookStateList`, and the `currentStatePointer` is shifted to the newly inserted address book state.

image::UndoRedoNewCommand1StateListDiagram.png[width="800"]

Step 3. The user executes `add n/David ...` to add a new person. The `add` command also calls `Model#commitAddressBook()`, causing another modified address book state to be saved into the `addressBookStateList`.

image::UndoRedoNewCommand2StateListDiagram.png[width="800"]

[NOTE]
If a command fails its execution, it will not call `Model#commitAddressBook()`, so the address book state will not be saved into the `addressBookStateList`.

Step 4. The user now decides that adding the person was a mistake, and decides to undo that action by executing the `undo` command. The `undo` command will call `Model#undoAddressBook()`, which will shift the `currentStatePointer` once to the left, pointing it to the previous address book state, and restores the address book to that state.

image::UndoRedoExecuteUndoStateListDiagram.png[width="800"]

[NOTE]
If the `currentStatePointer` is at index 0, pointing to the initial address book state, then there are no previous address book states to restore. The `undo` command uses `Model#canUndoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the undo.

The following sequence diagram shows how the undo operation works:

image::UndoRedoSequenceDiagram.png[width="800"]

The `redo` command does the opposite -- it calls `Model#redoAddressBook()`, which shifts the `currentStatePointer` once to the right, pointing to the previously undone state, and restores the address book to that state.

[NOTE]
If the `currentStatePointer` is at index `addressBookStateList.size() - 1`, pointing to the latest address book state, then there are no undone address book states to restore. The `redo` command uses `Model#canRedoAddressBook()` to check if this is the case. If so, it will return an error to the user rather than attempting to perform the redo.

Step 5. The user then decides to execute the command `list`. Commands that do not modify the address book, such as `list`, will usually not call `Model#commitAddressBook()`, `Model#undoAddressBook()` or `Model#redoAddressBook()`. Thus, the `addressBookStateList` remains unchanged.

image::UndoRedoNewCommand3StateListDiagram.png[width="800"]

Step 6. The user executes `clear`, which calls `Model#commitAddressBook()`. Since the `currentStatePointer` is not pointing at the end of the `addressBookStateList`, all address book states after the `currentStatePointer` will be purged. We designed it this way because it no longer makes sense to redo the `add n/David ...` command. This is the behavior that most modern desktop applications follow.

image::UndoRedoNewCommand4StateListDiagram.png[width="800"]

The following activity diagram summarizes what happens when a user executes a new command:

image::UndoRedoActivityDiagram.png[width="650"]

==== Design Considerations

===== Aspect: How undo & redo executes

* **Alternative 1 (current choice):** Saves the entire address book.
** Pros: Easy to implement.
** Cons: May have performance issues in terms of memory usage.
* **Alternative 2:** Individual command knows how to undo/redo by itself.
** Pros: Will use less memory (e.g. for `delete`, just save the person being deleted).
** Cons: We must ensure that the implementation of each individual command are correct.

===== Aspect: Data structure to support the undo/redo commands

* **Alternative 1 (current choice):** Use a list to store the history of address book states.
** Pros: Easy for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project.
** Cons: Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `VersionedAddressBook`.
* **Alternative 2:** Use `HistoryManager` for undo/redo
** Pros: We do not need to maintain a separate list, and just reuse what is already in the codebase.
** Cons: Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things.
// end::undoredo[]
=== Command Component
Command was implemented using a template model pattern. The reason for this implementation is because there is shared codes
and invariants among all the execution of the command classes (i.e. there is a call if tasks are overdue at every call to execute).
The common patterns in execution are implemented in the `execute` function of the command class which is declared final.
Concrete implementations of each execute function is implemented in the `executePrimitive` function of each subclass of command.
The implementation for executePrimitive fill the "variant" portion of the model template. Note that execute primitive is implemented as a
abstract method in command.

Simplified class diagram for the command component:

image::CommandComponentClassDiagram.png[width="1200"]

== Implementation
This section describes some noteworthy details on how certain features are implemented.

// tag::achievements[]
=== Achievement mechanism

==== Structural Overview
The achievement mechanism is facilitated by `AchievementRecord`. TaskManager is now composed of a `UniqueTaskList` as
well as an `AchievementRecord`. +
 +
`AchievementRecord` stores the achievement information of the user internally. These information include
the current `Xp`, current `Level`, total number of tasks completed, as well as the xp earned and number of tasks
completed by the user today and this week. To facilitate the tracking of the time-based achievements(xp earned and number of
tasks completed by today and this week), `AchievementRecord` also stores the dates when the time-based achievement fields should
be reset. +
 +
`AchievementRecord` also contains a field `displayOption` that specifies which set of achievement information should be
displayed on UI. The field is updated through the `achievements all-time`, `achievements today` or
`achievement this week` commands. +
 +
The storage of the `AchievementRecord` is facilitated by `XmlAdaptedAchievementRecord` which is saved together with
the list of `XmlAdaptedTask` in the `SerializableTaskManager`. +
 +
Integration of AchievementRecord in Model component:

image::AchievementModel.png[width="1200"]


==== Basic Mechanism
An `updateTaskStatus` method is implemented in `ModelManager` and exposed in the `Model` interface, this method is
called in the execution of complete command. Upon completion of a task, the status of task is updated to COMPLETED,
along with that, the `AchievementRecord` is also updated with the new xp. Current xp, number of tasks completed
increases, current level is recalculated and updated to match current xp. As the time based achievement fields should
be reset every day or week, checks are performed and the fields are reset if necessary. Xp earned and number of tasks
completed today and this week is then increased as well. +
 +
An `updateAchievementDisplayOption` method is implemented in `ModelManager` and exposed in the `Model` interface, which
is called in the execution of the achievements command. Before the `displayOption` field of the `AchievementRecord` is
updated, checks are perform to reset the time based achievement fields if necessary as well to ensure that they are up
to date. The `displayOption` is then updated, an `AchievementsUpdatedEvent` is posted to notify UI, who then display
the set of achievement information as specified by user's command. +

Sequence diagram of the achievement mechanism:

image::AchievementSequence1.png[width="1200"]

image::AchievementSequence2.png[width="1200"]

Activity diagram of the update of time-based achievement fields:

image::AchievementActivity.png[width="500"]


==== Event-driven Interaction with other components

The achievement mechanism follows the event-driven interaction of model component with Storage and UI components.
When a task is marked as complete, both the `UniqueTaskList` and the `AchievementRecord` of the task manager is updated
to reflect the new status of the task and the new xp and level information. A `TaskManagerChangedEvent` is then posted
to `EventsCenter` and handled by both Storage and UI components to save the changes and feedback to user. +
 +
On top of the `TaskManagerChangedEvent`, an `AchievementsUpdatedEvent` is posted by the Model component every time
the `AchievementRecord` is update(on task completion or change of display option). This event is handled by the
`AchievementPanel` UI component which then update the achievement information displayed.

==== Design Considerations

Aspect: Associations Among `TaskManager`,`UniqueTaskList` and `AchievementRecord` +

* Alternative 1 (current choice): Integrate `AchievementRecord` into `TaskManager` as an additional field besides the
existing `UniqueTaskList`.
    ** Pros: Easy to implement, greater efficiency. As xp and level change always come together with task status change,
    we can update both the `UniqueTaskList` and `AchievementRecord` then save the `TaskManager` only once. Undo/redo
    commands that revert the status tasks would revert the xp and level as well, matching between task status and
    corresponding achievements is guaranteed.
    ** Cons: `TaskManager` now has another reason of change, breaks Single Responsibility Principle.

* Alternative 2: Implement `AchievementRecord` as another component outside of `TaskManager` and let them communicate
with events.
    ** Pros: Follows Single Responsibility Principle. `TaskManager` handles only task operations, achievement
     information is handled by `AchievementRecord` independently.
     ** Cons: Logic is duplicated twice. For example, we would need to implement a `VersionedAchievementRecord` besides
     the current `VersionedTaskManager` to support undo/redo. A lot of overhead will result from the communication
     between `TaskManager` and `AchievementRecord` as well.

Aspect: Managing display option of `AchievementRecord`. +

* Alternative 1 (current choice): Use and additional field `displayOption` in `AchievementRecord` to keep track of
display option. The field is updated when user uses the `achievements all-time`, `achievements today` or `achievement
this week` commands to specify their choices.
    ** Pros: As the display option is saved inside the `AchievementRecord` of `TaskManager`, undo/redo of the
    achievements command is easily supported. `AchievementPanel` UI component can simple decide which set of
    achievements to display based on the current value of the `displayOption` field.
    ** Cons: `AchievementRecord` needs to save the display option besides the achievement information, this breaks the
    Single Responsibility Principle.

* Alternative 2: Use `AchievementPanel` UI component to save and manage the update of display option.
    ** Pros: Follows Single Responsibility Principle. `AchievementRecord` handles only achievement information. Greater
    cohesion as the display of achievements is handled by the `AchievementPanel` UI component alone.
     ** Cons: `AchievementPanel` needs to save the states of the `displayOption` to support undo/redo. Undo/redo of
     the achievements command needs to be implemented and handled separately from all other commands, breaks
     abstraction.
// end::achievements[]

// tag::complete[]

=== Batch Completion via Label feature
==== Current Implementation

The batch completion mechanism is facilitated by `CompleteLabelCommand`.
It extends `CompleteCommand` and encapsulates the internal logic of finding task and completing multiple
tasks atomically.

Additionally, in order to facilitate the finding of task and completing tasks atomically, the
following auxiliary classes have been created / extended as a result:

* `LabelMatchesKeywordPredicate` -- Extension of the functional interface `Predicate<E>`
** This class is required to encapsulate the logic of determining if a task has a `Label` matching
the desired `Label` (case-insensitive).

*Updated*

* `Model` -- Extends with a rollback() method
* `ModelManager` -- Extends with a rollback() method
* `VersionedTaskManager` -- Implements a rollback() method
* `CompleteCommandParser` -- Extended to parse two different formats, `Index` and `Label` based
commands

These are the methods in the CompleteCommand class supporting the batch completion:

* `#completeAllTasksReturnStringOfTasks(Model)`
* `#completeOneTaskReturnStringOfTasks(Task, Model)`

[NOTE]
The `CompleteLabelCommand` class inherits from the `CompleteCommand` class. It takes in a
`Task<Predicate>` while another subclass of `CompleteCommand`, `CompleteIndexCommand`
takes in an `Index` to support polymorphic behavior for both a single operation and batch operation.

Given below is an example usage scenario and how the undo/redo mechanism behaves at each step.

_Premise: The application has several tasks tagged with the label: many._

Step 1. The user executes `complete l/many` command to complete all the tasks labelled `many`.

Step 1.1. The argument `String` is passed to  the `CompleteCommandParser`, which checks to see
if the user's input contains a label, then calls `CompleteCommandParser#parseLabel(...)`. As a
result a new `CompleteCommand` instance containing a  `LabelMatchesKeywordPredicate` which
will only test true against a `Task` containing a `Label::many`.

Step 1.2. A chain of event triggers, ultimately calling `CompleteCommand#execute(...)` for the
created instance. Subsequently `CompleteCommand#completeAllTasksReturnStringOfTasks(...)` is
called which handles the logic for updating all valid completable tasks matching the predicate.

image::CompleteViaLabelOnFail.png[width="1200"]

[NOTE]
If a command fails its execution, it will call `Model#rollbackTaskManager()`, so
all current changes will be reset to the latest commit / state in `taskManagerStateList`.

image::CompleteViaLabelOnSuccess.png[width="1200"]

Step 1.2.1 If all tasks are updated successful, `Model#commit()` will be called.

Step 2. The user sees all tasks previously displayed on the screen which matches the label change
it's status to `COMPLETED`

==== Design Considerations

===== Aspect: Implementation of atomicity

* **Alternative 1 (current choice):** Calling `Model#rollback()` when an exception is caught,
otherwise `Model#commit()`
** Pros: This implementation defensively codes for scenarios where CommandExceptions are thrown, thus
ensuring that there are no partially-done batch operation resulting in harder to debug state.
** Cons: Increases coupling of components.
* **Alternative 2:** Doing a check on all tasks and only proceeding to update the model and
commit if deemed that all tasks can be completed successfully else throw an exception.
** Pros: Reduces coupling.
** Cons: Unable to handle unforeseen failure to complete, resulting in a partially committed
batch operation.

===== Aspect: Handling different CompleteCommand behaviour

* **Alternative 1:** Overloading the constructors and implementing the logic for
both behaviours within.
** Pros: Groups possibly tightly coupled code together into a single class; thus reducing
coupling.
** Cons: Possibly goes against the Separations of Concerns principle.
* **Alternative 2 (current choice)** Implementing `CompleteCommand` as an abstract class. Each class would then inherit
and implement the abstract methods, providing different polymorphic behaviours for `CompleteCommand`. Currently, the
two different behaviours implemented are: completion via index and completion via label.
** Pros: Clear separation of concern, respecting the Single Responsibility Principle.
** Cons: Harder to initially design properly.

[NOTE]
Alternative 2 was considered for `CompleteCommandParser`. However in this case, it is hard to determine whether
the argument is meant for `CompleteLabelCommand` or `CompleteIndexCommand` until actually parsing, As such, it could be
viewed that the job of figuring out what to parse the argument as is subsumed under the concerned of parsing. Thus
`CompleteCommandParser` is viewed to still respect the Single Responsibility Principle, and it's separation may result in
a high amount of coupling.

===== Aspect: Representation of predicate to be stored by CompleteCommand

* **Alternative 1 (current choice):** As an explicit implemented class
`LabelMatchesKeywordPredicate`.
** Pros: Notion of equality can be overloaded. This allows for proper checking of equality in every class composing the
`LabelMatchesKeywordPredicate`. In sum, it allows for the checking of structural equality rather than just referential
equality.
** Cons: Creation of an extra class requires more understanding by developers to pick up the
quirks as opposed to commonly recognised _Alternative 2_
* **Alternative 2:** Declaration of predicate as an anonymous function
** Pros: Easily understood by developers who are familiar with Functional Interfaces being Single
 Abstract Methods.
** Cons: Inability to properly check for equality.

=== Model Rollback feature
==== Current Implementation

Allows for any uncommitted changes to be discarded.

* `Model` -- Extends with a `rollback()` method
* `ModelManager` -- Extends with a `rollback()` method
* `VersionedTaskManager` -- Implements a `rollback()` method

When `VersionedTaskManager#Rollback()` is called, the current data is reset to the state of the
latest commit. Internally, `VersionedTaskManager#resetDate(...)` is called to reset the data to
the latest commit, also the `currentStatePointer` is set to point at the index of the latest
commit in `taskManagerStateList`.

image::RollbackModelSequenceDiagram.png[width="1200"]

_Internal calls of `VersionedTaskManager.resetData(...)` has been omitted for brevity_
// end::complete[]
// tag::dependency[]

=== Dependency Feature Modelling
==== Current Implementation
The dependency mechanism is facilitated by an embedded dependency object. This object internally represents dependency with
a hashset that contains the hashcode of the object that the task is dependent upon.

image::DependencyCommandSequenceDiagram.png[width="1200"]

==== Design Considerations
===== Aspect: Modelling of the embedded dependency object.

* ** Alternative 1(current choice):** Add a new string of the hashcode into the hashset.
** Pros: Simple to implement. There is no task creation propogation when task dependency is added. (refer to alternative 2).
Easy to reform the dependency graph.
** Cons: Some functions such as UI display might require a details of the dependee task. Additional complexity incurred when
finding details of the dependee task given its hashcode.

* ** Alternative 2: **Add (a reference to) the dependant Task object into the hashset.
** Pros: It allows an easy reference to the task object. Allows creation of a real-time dependency graph, which is referenced
to rather than recreated every time a topological sort or a cyclical check is needed.
** Cons: Introduces unnecessary complications.
*** When saving to storage, the hashcodes needs to be retrieved. But when retrieving from storage, the parser needs to first load the dependencies
as a set of hashcodes, and can only perform the tasks reference once all tasks are instantiated from storage.
*** Tasks are immutable, so whenever a task dependency is added, all connected components of the graph needs to be reinstantiated.
i.e. Task A has a new dependency. Task A has to be recreated with the additional dependency. After this new task is created, all
other tasks that depends on A has to be recreated.

=== Modelling Dependency Validity
==== Current Implementation
The dependency graph is the graph representing the dependencies between the task objects. A graph model needs to be created
so useful functions can be implemented such as cyclic and topological sort.

==== Design Considerations
===== Aspect: Real-time graph or graph instantiated on function call.
* **Alternative 1(current choice):** Graph is only instantiated when needed.
** Pros: Graph does not have to be updated or maintained.
** Cons: Slight increase in latency, but mitigated by the fact that it is likely that a typical user won't
have an extremely large amount of tasks.
* ** Alternative 2:** Graph created on start-up and maintained during run-time.
*** Pros: Slightly faster speed for dependency related commands.
*** Cons: Upkeep of graph is slightly more complex to implement, only for a slightly shorter run-time

===== Aspect: Task dependency modelled as a graph
* **Alternative 1(current choice):** Using a graph.
** Pros: With a graph, major problems with task dependency can be identified. The most major problem is
cyclic dependency, which is when a set of tasks have a dependency to each other and hence they cannot be completed because they
depend on each other.
A topological sort can also be performed on the graph to order tasks by the number of dependencies.
** Cons: nil
// end::dependency[]
// start::time[]

=== Monitoring time
==== Current Implementation
Time is of key importance when dealing with the `TaskManager`. We implement and represent time using the ubiquitous
`Date` class in Java. The class `DueDate` internally uses the `Date` class, and harnesses built in capabilities such as
date comparison. The precision of time for tasks is to the minute, that is the `AddCommand` can accept a `DueDate`
accurate to the minute.

A check on whether any of the tasks are overdue is done before the execution of every command/

===== Design Considerations
====== Aspect: Implementing the check on whether a task is overdue
* **Alternative 1 (current choice):** Run a check before the execution of every command
** Pros: From a user experience perspective, the user should not expect there to be a commit to state every time a task is overdue. i.e. An undo command
should never undo an overdue. Simple implementation prevents race conditions (refer to cons of alternative 2).
** Cons: If a user does not input a command, the task state will not be updated. (Mitigated by the fact that
the number of commands that a person uses likely occurs at a higher rate than the number of tasks itself).
* **Alternative 2:** Run a cron job that checks at a regular interval if the task is overdue
** Pros: The overdue state of the task is definitely current
** Cons: Potential race condition and might introduce latency to the application.
// end::time[]



=== List

The functionality of the default `list` command is as expected (and documented), that is all tasks are listed.
The date filters are dependent on the due date of the task, and the current date.

The Current Date is retrieved using Java's `Calendar`, and is adjusted to be the end of the day, week, or month
depending on the `ListCommand` 's option. A predicate is then created to check if a given `Task` is before this date.
This predicate is passed as an argument to update filtered Tasks.

// tag::gamemode-impl[]
=== Game Manager

==== Current Implementation

The GameManager class is responsible for the gamification aspects of WatchOver.

image::GameManagerSequenceDiagram.png[width="1200"]

A GameManager object is owned by a TaskManager, available to be called by its other methods. **Any calls from anywhere requiring XP evaluation must be passed through the current GameManager**.

The GameManager, in turn, owns a GameMode object. GameMode is implemented as an abstract class, and specific implementations of game modes must extend the abstract GameMode. The GameMode handles the actual appraisal of tasks for XP, delegated from the GameManager.

The GameMode has access to the information of the Task being completed. Based on any detail of the Task, the GameMode can decide how much to award. The default FlatMode awards based on `Status` of the task, where `IN_PROGRESS` tasks are awarded a full amount of XP whereas `OVERDUE` tasks are awarded somewhat less.

GameModes take in parameters determining the characteristics of the mode during construction, if necessary. For example, in the `FlatMode()` constructor, arguments can be specified for how much XP a completed task should obtain, as well as how much XP an overdue task should obtain.

One key limitation of this implementation is that the start date of the task cannot be determined, as only the due date is tracked. As a result the Decreasing mode interpolates the drop over a fixed period, rather than tailoring it to each task by measuring how long the user took to complete the task relative to how distant the start and due dates are. This limitation might be overcome if a creation date is implemented as a field in Task. 

==== Design Considerations

===== Aspect: Location of Implementation

* **Alternative 1(current choice):** Using a separate GameManager class to calculate awarded XP.
** Pros: It is modular and isolated from the rest of the logic, resulting in higher maintainability.
** Cons: Less flexibility, and will apply flatly across all tasks, with no window for individual variation.

* **Alternative 2:** Embedding XP calculation logic within task completion logic.
** Pros: XP awards is primarily used when completing tasks. Placing code here would have relevant code closer together.
** Cons: It is not modular, resulting in higher coupling and lower maintainability.

* **Alternative 3:** Embedding XP calculation logic inside each individual task.
** Pros: This would allow users to set different modes for each individual task, rather than having a one-size-fits-all policy apply to all tasks. 
** Cons: Difficult for user to edit the modes of all tasks at one shot. Additionally, it has the potential to get messy.
// end::gamemode-impl[]

=== Logging
We are using java.util.logging package for logging. The LogsCenter class is used to manage the logging levels and logging destinations.

The logging level can be controlled using the logLevel setting in the configuration file (See Section 3.4, “Configuration”)

The Logger for a class can be obtained using LogsCenter.getLogger(Class) which will log messages according to the specified logging level

Currently log messages are output through: Console and to a .log file.

Logging Levels

SEVERE : Critical problem detected which may possibly cause the termination of the application

WARNING : Can continue, but with caution

INFO : Information showing the noteworthy actions by the App

FINE : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size

=== Configuration
Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: config.json).

== Documentation
We use asciidoc for writing documentation.

We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation
See UsingGradle.adoc to learn how to render .adoc files locally to preview the end result of your edits. Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your .adoc files in real-time.

=== Publishing Documentation
See UsingTravis.adoc to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format
We use Google Chrome for converting documentation to PDF format, as Chrome’s PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

Follow the instructions in UsingGradle.adoc to convert the AsciiDoc files in the docs/ directory to HTML format.

Go to your generated HTML files in the build/docs folder, right click on them and select Open with → Google Chrome.

Within Chrome, click on the Print option in Chrome’s menu.

Set the destination to Save as PDF, then click Save to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

chrome save as pdf
Figure 10. Saving documentation as PDF files in Chrome

=== Site-wide Documentation Settings
The build.gradle file specifies some project-specific asciidoc attributes which affects how all documentation files within this project are rendered.

Attributes left unset in the build.gradle file will use their default value, if any.
Table 1. List of site-wide attributes
Attribute name	Description	Default value
site-name

The name of the website. If set, the name will be displayed near the top of the page.

not set

site-githuburl

URL to the site’s repository on GitHub. Setting this will add a "View on GitHub" link in the navigation bar.

not set

site-seedu

Define this attribute if the project is an official SE-EDU project. This will render the SE-EDU navigation bar at the top of the page, and add some SE-EDU-specific navigation items.

not set

=== Per-file Documentation Settings
=== Site Template
The files in docs/stylesheets are the CSS stylesheets of the site. You can modify them to change some properties of the site’s design.

The files in docs/templates controls the rendering of .adoc files into HTML5. These template files are written in a mixture of Ruby and Slim.

Modifying the template files in docs/templates requires some knowledge and experience with Ruby and Asciidoctor’s API. You should only modify them if you need greater control over the site’s layout than what stylesheets can provide. The SE-EDU team does not provide support for modified template files.

== Testing
=== Running Tests
There are three ways to run tests.

The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.
Method 1: Using IntelliJ JUnit test runner

To run all tests, right-click on the src/test/java folder and choose Run 'All Tests'

To run a subset of tests, you can right-click on a test package, test class, or a test and choose Run 'ABC'

Method 2: Using Gradle

Open a console and run the command gradlew clean allTests (Mac/Linux: ./gradlew clean allTests)

See UsingGradle.adoc for more info on how to run tests using Gradle.
Method 3: Using Gradle (headless)

Thanks to the TestFX library we use, our GUI tests can be run in the headless mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command gradlew clean headless allTests (Mac/Linux: ./gradlew clean headless allTests)

=== Types of tests
We have two types of tests:

==== GUI Tests
These are tests involving the GUI. They include:

System Tests that test the entire App by simulating user actions on the GUI. These are in the systemtests package.

Unit tests that test the individual components. These are in seedu.address.ui package.

==== Non-GUI Tests
These are tests not involving the GUI. They include,

Unit tests targeting the lowest level methods/classes.
e.g. seedu.address.commons.StringUtilTest

Integration tests that are checking the integration of multiple code units (those code units are assumed to be working).
e.g. seedu.address.storage.StorageManagerTest

Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together.
e.g. seedu.address.logic.LogicManagerTest

=== Troubleshooting Testing
Problem: HelpWindowTest fails with a NullPointerException.

Reason: One of its dependencies, HelpWindow.html in src/main/resources/docs is missing.

Solution: Execute Gradle task processResources.

== Dev Ops
=== Build Automation
See UsingGradle.adoc to learn how to use Gradle for build automation.

=== Continuous Integration
We use Travis CI and AppVeyor to perform Continuous Integration on our projects. See UsingTravis.adoc and UsingAppVeyor.adoc for more details.

=== Coverage Reporting
We use Coveralls to track the code coverage of our projects. See UsingCoveralls.adoc for more details.

=== Documentation Previews
When a pull request has changes to asciidoc files, you can use Netlify to see a preview of how the HTML version of those asciidoc files will look like when the pull request is merged. See UsingNetlify.adoc for more details.

=== Making a Release
Here are the steps to create a new release.

Update the version number in MainApp.java.

Generate a JAR file using Gradle.

Tag the repo with the version number. e.g. v0.1

Create a new release using GitHub and upload the JAR file you created.

=== Managing Dependencies
A project often depends on third-party libraries. For example, Address Book depends on the Jackson library for XML parsing. Managing these dependencies can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives.
a. Include those libraries in the repo (this bloats the repo size)
b. Require developers to download those libraries manually (this creates extra work for developers)

Appendix A: Suggested Programming Tasks to Get Started
Suggested path for new programmers:

First, add small local-impact (i.e. the impact of the change does not go beyond the component) enhancements to one component at a time. Some suggestions are given in Section A.1, “Improving each component”.

Next, add a feature that touches multiple components to learn how to implement an end-to-end feature across all components. Section A.2, “Creating a new command: remark” explains how to go about adding such a feature.

[appendix]
== Target User Profile

Tech savvy students who need to keep their tasks organized and motivate themselves to complete them.

The target age group is from 15 years old to 25 years old.

Attributable to our target demographic are the following qualities:

  * Adept with technology
  * Inclined to vicariously project a virtual avatar's experience unto themselves
  * Inclined against keeping data on physical mediums
  * Perpetually experiencing the continuous bombardment of deadlines from assignments

[appendix]
== Appendix B: Value proposition

By offering a gamified experience, we hope to be able to improve the user experience and keep users motivated in completing their tasks.

[appendix]
== Appendix C: User Stories
Priorities: High (must have) - * * *, Medium (nice to have) - * *, Low (unlikely to have) - *
|===
| Priority   | As a ...  | I want to ... | So that I can ...
| * * * | organised student | apply lables to my task | focus on tasks
| * * * | forgetful student | alerted of important deadlines | not forget about tasks
| * * * | busy person | easily prioritise tasks | get important things out of the way first
| * * * | organised student | have tasks organised by categories that they are under | manage
different aspects of life better
| * * * | proactive individual | view the day's task at a glance | I know what I need to do
| * * * | user | see task organized between todos and dones | better organisation
| * * * | user | see a list of tasks that needs attention at present time| I may pay attention to
them first
| * * | long-sighted quantitative person |  overview of my past tasks of the week | I can track
my progress and evaluate how I am doing.
|* * | user | have rewards for completing tasks | continue doing tasks
|* *| user | see list of tasks that need my attention most at the present time | pay attention to
 them first
| * * | user | see QOTD for basic motivation | motivation
| * * | user that is demoralized easily | get positive encouragement |stay motivated
| * * | user | negative reinforcement  | stay motivated
|* *| user | statistics function | keep track of progress
| * * | user | insights function | keep track of progress
|* *| competitive user | compete with friends | challenge myself and peers
| * | person without arms | have the computer interpret my words | type with my toes
| * | person who hates rules | enter tasks in a specified format and computer should interpret for me | easy addition of tasks
| * | visual person | colour coding in tasks | visually discern between tasks
| * | user | feedback on completion of tasks | better plan ways to handle tasks
| * | lazy student | provide intuitive information about the chaining to tasks | easy to tell end of task
| * | user | customize persona | make tasks seem more personal
| * | unmotivated student | see tasks creatively explosively destroy themselves | derive more enjoyment
|===

[appendix]
== Use cases
Only features that require more than a few steps to implement will be shown.

=== Use case: Display Welcome Screen
==== MSS
.  User logs in successfully
.  Application fetches QOTD and shows it.
.  Application then displays **10** tasks sorted by ascending deadline.

Use case ends.

==== Extensions

* 3a. There are less than **10** tasks available
** 3a1. Let the number of tasks available be `n`, then `n` tasks will be shown.

Use case ends.

* 3b. There are multiple tasks with the same deadline.
** 3b1. Tie will be broken by the lexicographic order of Task name
** 3b2. If multiple tasks have the same lexicographic order, the outputted task will be
non-deterministic

Use case ends.

=== Use case: Display Motivational Quote (MQ) on task completion
==== MSS
. User marks task as complete.
. Application shows MQ.

Use case ends.

==== Extensions

* 1a. User marks multiple tasks as complete.
** 1a1. Application still shows only one MQ.

Use case ends.

=== Use case: List Task
==== MSS
. User requests to list tasks, fulfilling a (potentially empty) set of criteria.
. Application shows a list of corresponding tasks.

Use case ends.

==== Extensions
* 1a. No matches found.
** 1a1. Application informs user that no tasks matching the specified criteria have been found.

Use case ends.

=== Use case: Add task
==== MSS
. User requests to add a task in the list
. Application adds the task

Use case ends.

==== Extensions
* 1a. The task already exists.
** 1a1. Application shows an error message.

Use case resumes at step 1 in MSS.

* 1b. The user enters the add command in a wrong format.
** 1b1. Application shows an error message.

Use case resumes at step 1 in MSS.

=== Use case: Add dependency for task
==== MSS
. User requests to add a dependency between tasks
. Application adds the task dependency

Use case ends.

==== Extensions
* 1a. The additional task dependency creates a cyclic dependency
** 1a1. Application shows an error message, rejects the additional task dependency

Use case resumes at step 1 in MSS.

* 1b. The user enters the add dependency command in a wrong format.
** 1b1. Application shows an error message.

Use case resumes at step 1 in MSS.

=== Use case: Remove dependency for task
==== MSS
. User requests to remove a dependency between tasks
. Application removes the task dependency

Use case ends.

==== Extensions
* 1a. The user enters the remove dependency command in a wrong format.
** 1a1. Application shows an error message.

Use case resumes at step 1 in MSS.

=== Use case: Delete task
==== MSS
. User requests to delete a task with a particular index
. Application deletes the task

Use case ends.

==== Extensions
* 1a. A task with the specified index does not exist.
** 1a1. Application shows an error message.

Use case resumes at step 1 in MSS.

* 1b. The task with the specified index is already deleted.
** 1b1. Application shows an error message.

Use case resumes at step 1 in MSS.

=== Use case: Viewing Command History
==== MSS
. User requests to view command history.
. Application displays command history.

Use case ends.

==== Extensions
* 1a. Command history is empty.
** 1a1. Application informs user that there is no command history.

Use case ends.

=== Use case: Undoing Last Command
==== MSS
. User requests undoing last command.
. Application resets state to before last state-changing command.

Use case ends.

==== Extensions
* 1a. Command history is empty.
** 1a1. Application informs user that there is no past history to undo.

Use case ends.

=== Use case: Redoing Last Command
==== MSS
. User requests redoing last command.
. Application resets state to before last state-changing command was undone.

Use case ends.

==== Extensions
* 1a. The immediately preceding command (ignoring redone undos) is not an undo command
** 1a1. Application informs user that there is no undo to redo.

Use case ends.

=== Use case: Completing Task (Single)
==== MSS
. User marks task as complete.
. Application reports both points earned and current points to user.

==== Extensions
* 1a. An error occurs, causes one of the task to not be completed
** 1a1. Application displays error message, no points are earned either.

* 2a. User earns enough points to level up
** 2a1. Application displays a congratulatory message, current points, and points earned to user.

=== Use case: Completing Task (Batch via `Label`)
==== MSS
. User marks a batch of tasks with the same specified `Label` as complete.
. Application reports both points earned and current points to user.

==== Extensions
* 1a. An error occurs, causes one of the tasks to not be able to be completed
** 1a1. Application displays an error message, resetting the batch of tasks to their
pre-completed state and no points are earned.

* 2a. User earns enough points to level up
** 2a1. Application displays a congratulatory message, current points, and points earned to user.

=== Use case: Display Statistics
==== MSS
. User requests for statistics.
. Application fetches data and displays statistics.

==== Extensions
* 2a. There are no statistics.
** 2a1. Application displays a flavour text explaining that the user needs to complete a task first to get statistics.

Use case ends.

=== Use case: Failing to complete task
==== MSS
. User fails to complete tasks on time
. Application displays points lost and current current points to user.

==== Extensions
* 2a. User loses enough points that it level down.
    * 2a1. Application displays a warning message, current points, and points lost to user.

Use case ends.

[appendix]
== Non-functional requirements
- There should be no noticable lag when typing on the command line.
- Should work on any mainstream OS as long as it has Java 9 or higher installed.
- Storage of application data will be in a text file.
- Should be able to hold up to 1000 tasks without a noticable decline in performance.
- Should not take more than 3 seconds to complete a command.
- System should be maintainable with proper documentation.
- Proper feedback to user when error occurs.

[appendix]
== Glossary

A glossary serves to ensure that all stakeholders have a common understanding of the noteworthy terms, abbreviation, acronyms etc.

|===
| Word         | Meaning

|   Task
| A piece of work to be completed and is registered by the user

| Application  |  Refers to the CLI application registered by the user
|Mainstream OS    | Windows, Linux, Unix, OS-X
|Points | A unit of measurement to measure current experience
| Level | A larger unit of measurement to measure experience.
|===

[appendix]
== Instructions for Manual Testing

Given below are instructions to test the app manually.

[NOTE]
These instructions only provide a starting point for testers to work on; testers are expected to do more _exploratory_ testing.

=== Launch and Shutdown

. Initial launch

.. Download the jar file and copy into an empty folder
.. Double-click the jar file +
   Expected: Shows the GUI with a set of sample tasks. The window size may not be optimum.

. Saving window preferences

.. Resize the window to an optimum size. Move the window to a different location. Close the window.
.. Re-launch the app by double-clicking the jar file. +
   Expected: The most recent window size and location is retained.

