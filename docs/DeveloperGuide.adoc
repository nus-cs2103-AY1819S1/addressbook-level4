= Developer Guide
:site-section: DeveloperGuide
:relfileprefix: team/
:imagesDir: images
:stylesDir: stylesheets

By: `T10-3`      Since: `Oct 2018`      Licence: `MIT`

== Setting up

=== Prerequisites

. *JDK `9`* or later
+
[WARNING]
JDK `10` on Windows will fail to run tests in <<UsingGradle#Running-Tests, headless mode>> due to a https://github.com/javafxports/openjdk-jfx/issues/66[JavaFX bug].
Windows developers are highly recommended to use JDK `9`.

. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.


=== Setting up the project in your computer

. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.
. Open link:{repoURL}/src/main/java/seedu/address/storage/XmlAdaptedWord.java[`XmlAdaptedWord.java`] and link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow.java`] and check for any code errors
.. Due to an ongoing https://youtrack.jetbrains.com/issue/IDEA-189060[issue] with some of the newer versions of IntelliJ, code errors may be detected even if the project can be built and run successfully
.. To resolve this, place your cursor over any of the code section highlighted in red. Press kbd:[ALT + ENTER], and select `Add '--add-modules=...' to module compiler options` for each error
. Repeat this for the test folder as well (e.g. check link:{repoURL}/src/test/java/seedu/address/commons/util/XmlUtilTest.java[`XmlUtilTest.java`] and link:{repoURL}/src/test/java/seedu/address/ui/HelpWindowTest.java[`HelpWindowTest.java`] for code errors, and if so, resolve it the same way)

=== Verifying the setup

. Run the `seedu.address.MainApp` and try a few commands
. <<Testing,Run the tests>> to ensure they all pass.

=== Configurations to do before writing code

==== Configuring the coding style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.adoc[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify,

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS)
. Select `Editor` > `Code Style` > `Java`
. Click on the `Imports` tab to set the order

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Updating documentation to match your fork

After forking the repo, the documentation will still have the SE-EDU branding and refer to the `se-edu/addressbook-level4` repo.

If you plan to develop this fork as a separate product (i.e. instead of contributing to `se-edu/addressbook-level4`), you should do the following:

. Configure the <<Docs-SiteWideDocSettings, site-wide documentation settings>> in link:{repoURL}/build.gradle[`build.gradle`], such as the `site-name`, to suit your own project.

. Replace the URL in the attribute `repoURL` in link:{repoURL}/docs/DeveloperGuide.adoc[`DeveloperGuide.adoc`] and link:{repoURL}/docs/UserGuide.adoc[`UserGuide.adoc`] with the URL of your fork.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

After setting up Travis, you can optionally set up coverage reporting for your team fork (see <<UsingCoveralls#, UsingCoveralls.adoc>>).

[NOTE]
Coverage reporting could be useful for a team repository that hosts the final version but it is not that useful for your personal fork.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based)

==== Getting started with coding

When you are ready to start coding,

1. Get some sense of the overall design by reading <<Design-Architecture>>.
2. Take a look at <<GetStartedProgramming>>.

== Implemention
**Trivia:**

The trivia function is facilitated by `LearnVocabulary`.
Besides storing a `UniqueWordList`, `LearnVocabulary` also stores the current trivia question as `triviaQuestion` and stores a list of trivia questions is `triviaQuestionList`.
Scores for a trivia game are also stored using `currentScore` and `maxScore`.

Additionally, it also implements the following operations:

* `setTriviaList` -- sets the trivia question list based on the current vocabulary list
* `setTrivia` -- sets the trivia question based on `triviaQuestionList`
* `getTrivia` -- outputs the current trivia question.
* `updateScore` -- adds 1 to the the`currentScore`
* `clearTrivia` -- clears the current trivia question as well as removing it from the `triviaQuestionList`
* `isTriviaMode` -- a boolean to indicate whether the model is currently in trivia mode.
* `toggleTriviaMode` -- toggle trivia mode

These operations are exposed in the `Model` interface as `Model.setTrivia()` and `Model.getTrivia()`.


Outlined below is how the trivia function operates at each step:

Step 1. The user inputs trivia in the CLI.

Step 2. `TriviaCommand.execute()` checks `lastShownList` to see if it is empty.

[NOTE]
If `lastShownList` is empty, `TriviaCommand.execute()` will terminate and a message will be displayed to the user indicating that the user has to add words in before `trivia` can be used

Step 3. `TriviaCommand.execute()` calls `toggleTriviaMode` to indicate that LearnVocabulary is in trivia mode.

[NOTE]
While in trivia mode, every command the user types will be parsed as `TriviaAnsCommand`. Trivia mode can be exited by either completing the trivia or typing "triviaExit"

Step 4. `TriviaCommand.execute()` now calls `Model.setTriviaList()` to set the trivia question within `LearnVocabulary`.

Step 5. `TriviaCommand.execute()` calls `Model.getTrivia()` and outputs to the user.

**Answer**

The answer command is indicated as `TriviaAnsCommand` in `commands`. It will take in arguments passed in by the user and checks whether it is the correct/wrong answer to the current trivia question.

Outlined below is how the answer function operates:

Step 1: User enters  his/her argument.

[NOTE]
Attempting to call the `answer` command without first calling `trivia` will result in an error.

Step 2: `TriviaAnsCommandParser` processes the argument and parses it to `TriviaAnsCommand`.

Step 3: `TriviaAnsCommand.execute()` checks the passed argument is the same word as `triviaQuestion` in `LearnVocabulary`.

Step 4: Outputs a correct or wrong message based on the result in step 3.

**Select**

The select command is indicated as `SelectCommand` in `commands`, and inherits the `Command` class. It selects a word identified by a user using its index from the review list.

Below is a description on how the select function operates:

Step 1: User calls “select + [index]” where `index` is the index of the word that the user wants to select.

Step 2: `SelectCommand` checks passed arguments.

Step 3: If the user leaves out or in other ways enters an invalid index, `SelectCommand` throws an exception. Otherwise it returns the desired word.

**groupadd**

The select command is indicated as `GroupAddCommand` in `commands`, and inherits the `Command` class. It create a new group in which the uesr can put words.

Below is a description on how the select function operates:

Step 1: User calls “groupadd + [groupname]” where `groupname` is the name of the newly added group.

Step 2: `GroupAddCommand` checks passed arguments.

Step 3: If the user set a group name that has already existed, the system do nothing(no dublicate). Otherwise it creates a new group.

**groupdelete**

The select command is indicated as `GroupDeleteCommand` in `commands`, and inherits the `Command` class. It delete a group and all words in it.

Below is a description on how the select function operates:

Step 1: User calls “groupdelete + [groupname]” where `groupname` is the name of the desired deleted group.

Step 2: `GroupDeleteCommand` checks passed arguments.

Step 3: If the user set a group name that does not exist, the system throw an exception. Otherwise it deletes the assigned group. Especially, for those words which exist in this only deleted group, those words would also be deleted automately.

**Show implementation**

The show command is indicated as `Show` in `commands`, and inherits the `Command` class. It is a more advanced version of `Find` in a sense that it displays the word's definition on the Ui screen page. The reason why this was created and `Find` was left alone was because we wanted to have more abstraction in terms of code.

As for `find`, perhaps the team and I can find another purpose for it.

As such, `Show` was implemented with a more Ui state of mind, to ensure the user's ease of use when finding the words for display of their meanings as AddressBook level 4 did not cater to this particular arrangement.

Moreover, it also encompasses multiple words, which meant that users can always pick and dump a whole bunch of words and it will filter out as needed, accordingly.

Below is a description on how the select function operates:

Step 1: User wants to query a bunch of words and find out their meanings, tags altogether.

[NOTE]
Multiple words are allowed to be queried. This allows for more flexibility compared to the Ui option.

Step 2: `ShowCommand` checks through the entire xml file of LearnVocabulary and filters out the ones that were keyed in.

Step 3: The result is the list of filtered words, together with their definition and tags being displayed.

**Learn**

The backbone of LearnVocabulary would have to be the `Learn` command, because it allows the user to query words from the internet and parse their meanings into readable format for storage.

The learn command is indicated as `Learn` in `commands`, and inherits the `Command` class. It enables the user to "learn" a word from the world wide web.

This command is delicate in the sense that it requires the use of Internet, should there be an absence of Internet connection, it has already been taken care of via throwing an Exception.

There was a discussion to have an "Offline" version of the dictionary so that we can better attend to the tests, especially since it might be an offline environment.

However, due to the lack of resources online and the fact that the API for dictionary only allows for 250 queries, we opted to do the online version instead.

It is great to also note that a fresh new copy would give the user access to a few preconfigured words at the disposal of the user.

Functions added:

* `Dictionary#invoke()` -- calls the main function of Dictionary which links it to LearnVocabulary
* `Dictionary#isConnectedToInternet()` -- checks to see if there is an Internet connection established.
* `Dictionary#isWordInOnlineDictionary()` -- checks to see if it is a valid word and if it exists in Dictionary.com

Below is a description on how the learn function operates:

Step 1: User wants to learn this new word he just heard of, eg: Happiness

Step 2: User would type the word followed by the command learn, eg: learn happiness

Step 3: The word will be searched online, should it be successful, the word and meaning will be displayed on screen.

[NOTE]
The newly queried word would be attached with a "toLearn" tag, which allows the user to know that he/she just queried the word and can leave it for the future to learn it.

Step 4: The word is then stored within the storage file.

**Word Of The Day**

The Word Of The Day command is indicated as `WordOfTheDay` in `commands`, and inherits the `Command` class. It enables the user to display the current word of the day taken from website Dictionary.com. Similarly to the "learn" command, this command also requires a working internet connection. It is impossible to make this feature available offline since the word of the day cannot be predicted on Dictionary.com

Functions added:

* `Dictionary#doesWordOfTheDayExist()` -- Checks to see if the word of the day exist on Dictionary.com and returns the word of the day page as a Document object.
* `Dictionary#fetchWordOfTheDay()` -- Parses the word of the day and its meaning from the Document object returned by `doesWordOfTheDayExist()` and returns itself (Dictionary object).

Below is a description on how the Word Of The Day function operates:

Step 1: User cannot think of a word so he/she wants to display the word of the day on Dictionary.com.

Step 2: User would make sure that there is a working internet connection.

Step 3: User would type "word" into the command line.

Step 4: The word of the day will be fetched online. Should it be successful, the word of the day and its meaning will be displayed.

== Target user profile

People who would like to learn new words they see in their daily life more efficiently and use computer a lot. These people can be for example non-native english speakers and schools who want to use the program in language courses. In the future, target users will be extended to also other languages than english.

== Value propositions

The application helps the user to find the meaning of words. Upon finding the meaning of words, they will be stored into a “review list”, where the user can refresh their memory of the word that they had just learnt (similar to flash cards). In specific, we currently plan to give the user the meaning of the word and ask them to type the word correctly. If they can type in the word correctly for continuous several days, then the word will be deleted from the review list automatically. Besides, the user can also manually add words in the review list and delete words from the review list. In the end, this will help the user to learn the language.

== User stories

As a user, I want to be able to learn new English words everyday.

As a user, I want to be able to save words so that I can "collect" those words and review what I have learnt.

As a user, I want to test and challenge myself to improve my English.

As a user, I want to check the meaning of words.

As a non-native english speaker, I would like to classify words in different groups to manage them and learn them better.

As a non-native english speaker, I would like to lookup the definition of words.

As a non-native English speaker, I would like to learn words to improve my English.

== Use cases

**Add a word to the review list:**

User enters a word to add to the review list.

System checks if word exists in the dictionary and displays if the word could be successfully added or not. It also displays the meaning of the word.

Use case ends

**Finding a word in the review list or in the dictionary:**

User enters the word that he or she wants to look up

System checks that the word exists in the dictionary and displays the meaning of the word.

System also checks if the word is already in the review list and asks if the users wants to add it to the review list (if it is not already there).

Use case ends

*Trivia mode:*

MSS:
User inputs command (trivia)

System displays meaning of a selected word in user’s review list

User enters the word which corresponds to the meaning displayed.

System reveals the answer

Repeat steps 2 - 4 until 10 questions have been displayed
Use case ends

    Extensions:
    User’s review list is empty
    System displays that user’s review list is empty
    Use case ends.

*Group words together*

User inputs command (group)

System responds with helper text (group [word] in [group])

User enters “group gazelle in animals

System groups the word “gazelle” in “animals”

Use case ends

**List words individually from review list or groups**

User inputs command (list)

A helper text will appear (list, list [group], list [20 random entries])

System would pull up the data from storage

Use case ends

*Learn feature:*

User inputs command (learn)

User types in learn [word], the word will be queried online.

The definition of the entered word will be displayed and the user will learn it.

The word is then saved within the storage, where it can be edited in the future if need be.

Use case ends

*Show feature:*

User inputs command (show)

User types in show [word] (or show [word1] [word2]), the word(s) will be displayed on the Ui.

Use case ends.

*Non functional requirements*

Should work on any mainstream operating system as long as Java 9 or higher is installed.

Works by command line input and possibly a minimalistic GUI output

Handles at least one complete dictionary (e.g. english)

== Appendix A: User Stories
Priorities:
High (Need to have) - PPP, Medium (Nice to have) - PP, Low (Not very needed) - P

|===
|Priority |As a... |I want to... |So that I can...

|PPP
|Non-native English speaker
|Search for the meaning of words
|Improve my English abilities

|PPP
|Non-native English speaker
|Add/keep words that I have searched
|Reference them easily to learn better

|PPP
|Non-native English speaker
|Play a game that would improve my English capabilities
|Not get bored of the learning process and have fun at the same time

|PPP
|Non-native English speaker
|Refer to my native tongue while looking at English words
|Speed up the learning process much faster

|PPP
|Non-native English speaker
|Group words together
|Refer to them easily in the future

|PP
|English speaker
|Look up words
|Learn the meanings of words

|PP
|English speaker
|Play a game
|Improve my English further
